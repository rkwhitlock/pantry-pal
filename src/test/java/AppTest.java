import static client.model.ATranscribe.checkMealType;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;

import client.View;
import client.controller.MockRegenerateBehavior;
import client.model.MockLoginModel;
import client.model.RecipeDetailsMock;
import client.model.TranscribeMock;
import client.view.AccountScreen.MockAccountScreen;
import client.view.MainMenu.*;
import client.view.RecipeScreen.*;
import client.view.RecordScreen.*;

import java.io.IOException;
import java.net.URISyntaxException;
import java.util.HashMap;
import java.util.Map;
import javafx.geometry.Insets;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.layout.*;
import javafx.scene.text.TextAlignment;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import server.RequestHandler;

public class AppTest {

  TranscribeMock mockWhisper;
  RecipeDetailsMock mockGPT;

  @BeforeEach
  void setUp() {
    mockGPT = new RecipeDetailsMock();
    mockWhisper = new TranscribeMock();
  }

  /*
   * UNIT TEST
   *
   * checkMealType() should:  1) take in a string
   *                          2) check if input matches desired meal type options
   *                          3) return null if input doesn't comply
   *                          4) return lowercase version of the specified mealtype
   */
  @Test
  void testCheckMealType() {
    // testing all lowercase input
    String mealType = "breakfast";
    assertEquals("breakfast", checkMealType(mealType));

    // testing random uppercases with another desired type
    mealType = "LunCh";
    assertEquals("lunch", checkMealType(mealType));

    // testing random word out of context
    mealType = "Tired";
    assertEquals(null, checkMealType(mealType));

    // testing no input
    mealType = "";
    assertEquals(null, checkMealType(mealType));
  }

  /*
   * UNIT TEST
   *
   * newRecipe() should:  1) take in two strings
   *                      2) have the proper request body to send
   */
  @Test
  void testNewRecipe() {
    String mealType = "lunch";
    String ingredients = "potatoes, beans";
    try {
      mockGPT.newRecipe(mealType, ingredients);
    } catch (Exception e) {}

    assertEquals(
      "{\"max_tokens\":100,\"temperature\":1,\"model\":\"text-davinci-003\",\"prompt\":\"Can you create me a recipe for lunch with these ingredients potatoes, beans\"}",
      mockGPT.requestBody.toString()
    );
  }

  /*
   * UNIT TEST
   *
   * getRecipe() should:    1) get the entire recipe details
   *                        2) should return a string
   */
  @Test
  void testGetRecipe() {
    String mealType = "lunch";
    String ingredients = "potatoes, beans";
    try {
      mockGPT.newRecipe(mealType, ingredients);
    } catch (Exception e) {}

    assertEquals("ChatGPT\nmocked recipe", mockGPT.getRecipe());
  }

  /*
   * UNIT TEST
   *
   * getRecipeName() should:    1) get just the recipe's name
   *                            2) should return a string
   */
  @Test
  void testGetRecipeName() {
    String mealType = "lunch";
    String ingredients = "potatoes, beans";
    try {
      mockGPT.newRecipe(mealType, ingredients);
    } catch (Exception e) {}

    assertEquals("ChatGPT", mockGPT.getRecipeName());
  }

  /*
   * STORY TEST - create new recipe
   *
   * 1 - record meal type with transcribe
   * 2 - check meal type is correct
   * 3 - record ingredients with transcribe
   * 4 - check chatgpt prompt
   * 5 - check recipe generated by chatgpt
   * This tests how whisper and chatgpt work together and makes sure the request is correct
   *
   * uses TranscribeMock and RecipeDetailsMock classes
   * NOT TranscribeWhisper and RecipeDetailsChatGPT classes!!!
   *
   */
  @Test
  void testCreateNewRecipeStory() {
    String transcribedMealType = "";
    String transcribedIngredients = "";

    // 1 recording meal type
    mockWhisper.recordingMealType = true;
    try {
      transcribedMealType = mockWhisper.transcribe();
    } catch (Exception e) {}

    // 2 checking meal type is valid
    assertTrue(transcribedMealType != null);
    assertEquals("lunch", checkMealType(transcribedMealType));

    // 3 recording ingredients
    mockWhisper.recordingMealType = false;
    try {
      transcribedIngredients = mockWhisper.transcribe();
    } catch (Exception e) {}

    // 4 put meal type and ingredients into chatgpt and check prompt
    try {
      mockGPT.newRecipe(transcribedMealType, transcribedIngredients);
    } catch (Exception e) {}

    // checking prompt
    assertEquals(
      "{\"max_tokens\":100,\"temperature\":1,\"model\":\"text-davinci-003\",\"prompt\":\"Can you create me a recipe for lunch with these ingredients potatoes, beans\"}",
      mockGPT.requestBody.toString()
    );

    // 5 checking getRecipe() and getRecipeName() match expected output
    assertEquals("ChatGPT\nmocked recipe", mockGPT.getRecipe());
    assertEquals("ChatGPT", mockGPT.getRecipeName());
  }

  @Test
  void testAccountCreation(){
    MockAccountScreen mockAccountScreen = new MockAccountScreen();
    mockAccountScreen.inputUsername("username");
    mockAccountScreen.inputtedPassword("password");

    MockLoginModel mockLoginModel = new MockLoginModel();
    String response = mockLoginModel.performRequest(
      "PUT", mockAccountScreen.getUsername(), mockAccountScreen.getPasswword(), null);
    
    assertEquals("put username: " + mockAccountScreen.getUsername() + 
      " and password: " + mockAccountScreen.getPasswword() + " into server", response);
  }

  @Test
  void testAutomaticLogin(){
    // create account intially
    MockAccountScreen mockAccountScreen = new MockAccountScreen();
    mockAccountScreen.inputUsername("username");
    mockAccountScreen.inputtedPassword("password");

    MockLoginModel mockLoginModel = new MockLoginModel();
    mockLoginModel.performRequest(
      "PUT", mockAccountScreen.getUsername(), mockAccountScreen.getPasswword(), null);

    // toggle automatic login
    mockAccountScreen.toggleAutomaticLogin();

    // produce automaticLogin.txt when logging out
    String[] automaticLoginTxt = mockAccountScreen.automaticLoginTxt();

    // automatic login
    MockAccountScreen automaticLogin = new MockAccountScreen(automaticLoginTxt);

    String response = mockLoginModel.performRequest(
      "PUT", automaticLogin.getUsername(), automaticLogin.getPasswword(), null);
    
    //response indicates record of previous login
    assertEquals("username: " + mockAccountScreen.getUsername() + 
      " and password: " + mockAccountScreen.getPasswword() + " found in server. logging in", response);
  }

  @Test
  void testRegenerateRecipe() {
    // create new recipe normally
    String transcribedMealType = "";
    String transcribedIngredients = "";

    mockWhisper.recordingMealType = true;
    try {
      transcribedMealType = mockWhisper.transcribe();
    } catch (Exception e) {}

    mockWhisper.recordingMealType = false;
    try {
      transcribedIngredients = mockWhisper.transcribe();
    } catch (Exception e) {}

    try {
      mockGPT.newRecipe(transcribedMealType, transcribedIngredients);
    } catch (Exception e) {}

    // comparing original recipe with regenerated recipe
    MockRegenerateBehavior regenerator = new MockRegenerateBehavior();

    RecipeDetailsMock separateMockGPT = new RecipeDetailsMock();
    try {
      separateMockGPT.newRecipe(mockGPT.getMealType(), regenerator.regenerate(mockWhisper));
    } catch (IOException | InterruptedException | URISyntaxException e) {}

    assertEquals(mockGPT.requestBody.toString(), separateMockGPT.requestBody.toString());
    assertEquals(mockGPT.getRecipe(), separateMockGPT.getRecipe());
    assertEquals(mockGPT.getRecipeName(), separateMockGPT.getRecipeName());
  }
}
