import static client.model.ATranscribe.checkMealType;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;

import client.View;
import client.controller.MockRegenerateBehavior;
import client.model.MockLoginModel;
import client.model.RecipeDetailsMock;
import client.model.TranscribeMock;
import client.view.AccountScreen.MockAccountScreen;
import client.view.MainMenu.*;
import client.view.RecipeScreen.*;
import client.view.RecordScreen.*;

import java.io.IOException;
import java.net.URISyntaxException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javafx.geometry.Insets;
import javafx.scene.control.Button;
import javafx.scene.control.Label;
import javafx.scene.layout.*;
import javafx.scene.text.TextAlignment;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import server.MockRequestHandler;
import server.MyServer;
import server.RequestHandler;

public class AppTest {

  TranscribeMock mockWhisper;
  RecipeDetailsMock mockGPT;

  @BeforeEach
  void setUp() {
    mockGPT = new RecipeDetailsMock();
    mockWhisper = new TranscribeMock();
  }

  /*
   * UNIT TEST
   *
   * checkMealType() should:  1) take in a string
   *                          2) check if input matches desired meal type options
   *                          3) return null if input doesn't comply
   *                          4) return lowercase version of the specified mealtype
   */
  @Test
  void testCheckMealType() {
    // testing all lowercase input
    String mealType = "breakfast";
    assertEquals("breakfast", checkMealType(mealType));

    // testing random uppercases with another desired type
    mealType = "LunCh";
    assertEquals("lunch", checkMealType(mealType));

    // testing random word out of context
    mealType = "Tired";
    assertEquals(null, checkMealType(mealType));

    // testing no input
    mealType = "";
    assertEquals(null, checkMealType(mealType));
  }

  /*
   * UNIT TEST
   *
   * newRecipe() should:  1) take in two strings
   *                      2) have the proper request body to send
   */
  @Test
  void testNewRecipe() {
    String mealType = "lunch";
    String ingredients = "potatoes, beans";
    try {
      mockGPT.newRecipe(mealType, ingredients);
    } catch (Exception e) {}

    assertEquals(
      "{\"max_tokens\":100,\"temperature\":1,\"model\":\"text-davinci-003\",\"prompt\":\"Can you create me a recipe for lunch with these ingredients potatoes, beans\"}",
      mockGPT.requestBody.toString()
    );
  }

  /*
   * UNIT TEST
   *
   * getRecipe() should:    1) get the entire recipe details
   *                        2) should return a string
   */
  @Test
  void testGetRecipe() {
    String mealType = "lunch";
    String ingredients = "potatoes, beans";
    try {
      mockGPT.newRecipe(mealType, ingredients);
    } catch (Exception e) {}

    assertEquals("ChatGPT\nmocked recipe", mockGPT.getRecipe());
  }

  /*
   * UNIT TEST
   *
   * getRecipeName() should:    1) get just the recipe's name
   *                            2) should return a string
   */
  @Test
  void testGetRecipeName() {
    String mealType = "lunch";
    String ingredients = "potatoes, beans";
    try {
      mockGPT.newRecipe(mealType, ingredients);
    } catch (Exception e) {}

    assertEquals("ChatGPT", mockGPT.getRecipeName());
  }

  /*
   * STORY TEST - create new recipe
   *
   * 1 - record meal type with transcribe
   * 2 - check meal type is correct
   * 3 - record ingredients with transcribe
   * 4 - check chatgpt prompt
   * 5 - check recipe generated by chatgpt
   * This tests how whisper and chatgpt work together and makes sure the request is correct
   *
   * uses TranscribeMock and RecipeDetailsMock classes
   * NOT TranscribeWhisper and RecipeDetailsChatGPT classes!!!
   *
   */
  @Test
  void testCreateNewRecipeStory() {
    String transcribedMealType = "";
    String transcribedIngredients = "";

    // 1 recording meal type
    mockWhisper.recordingMealType = true;
    try {
      transcribedMealType = mockWhisper.transcribe();
    } catch (Exception e) {}

    // 2 checking meal type is valid
    assertTrue(transcribedMealType != null);
    assertEquals("lunch", checkMealType(transcribedMealType));

    // 3 recording ingredients
    mockWhisper.recordingMealType = false;
    try {
      transcribedIngredients = mockWhisper.transcribe();
    } catch (Exception e) {}

    // 4 put meal type and ingredients into chatgpt and check prompt
    try {
      mockGPT.newRecipe(transcribedMealType, transcribedIngredients);
    } catch (Exception e) {}

    // checking prompt
    assertEquals(
      "{\"max_tokens\":100,\"temperature\":1,\"model\":\"text-davinci-003\",\"prompt\":\"Can you create me a recipe for lunch with these ingredients potatoes, beans\"}",
      mockGPT.requestBody.toString()
    );

    // 5 checking getRecipe() and getRecipeName() match expected output
    assertEquals("ChatGPT\nmocked recipe", mockGPT.getRecipe());
    assertEquals("ChatGPT", mockGPT.getRecipeName());
  }

  /*
   * STORY TEST - account creation
   *
   * 1 - create screen to input user data
   * 2 - take user data and put into database
   * 3 - recognize user/database properly populated
   * 
   * This tests proper account creation and populating of the database
   * 
   */
  @Test
  void testAccountCreation(){
    // 1 create screen to input user data
    MockAccountScreen mockAccountScreen = new MockAccountScreen();
    mockAccountScreen.inputUsername("username");
    mockAccountScreen.inputtedPassword("password");

    // 2 take user data and put into database
    MockLoginModel mockLoginModel = new MockLoginModel();
    String response = mockLoginModel.performRequest(
      "PUT", mockAccountScreen.getUsername(), mockAccountScreen.getPasswword(), null);
    
    // 3 recognize user/database properly populated
    assertEquals("put username: " + mockAccountScreen.getUsername() + 
      " and password: " + mockAccountScreen.getPasswword() + " into server", response);
  }

  /*
   * STORY TEST - automatic login
   *
   * 1 - recognize user
   * 2 - logs in for them on recognition
   * 3 - reacts appropriately to user not found
   * 
   * This tests the recognition of a previous user and
   * creates a new account normally when not
   * 
   */
  @Test
  void testAutomaticLoginStory(){
    // create account intially
    MockAccountScreen mockAccountScreen = new MockAccountScreen();
    mockAccountScreen.inputUsername("username");
    mockAccountScreen.inputtedPassword("password");

    MockLoginModel mockLoginModel = new MockLoginModel();
    mockLoginModel.performRequest(
      "PUT", mockAccountScreen.getUsername(), mockAccountScreen.getPasswword(), null);

    // toggle automatic login
    mockAccountScreen.toggleAutomaticLogin();

    // produce automaticLogin.txt when logging out
    String[] automaticLoginTxt = mockAccountScreen.automaticLoginTxt();

    // 1 recognize previous user
    MockAccountScreen automaticLogin = new MockAccountScreen(automaticLoginTxt);

    String response = mockLoginModel.performRequest(
      "PUT", automaticLogin.getUsername(), automaticLogin.getPasswword(), null);
    
    // 2 response reflects logging in automatically
    assertEquals("username: " + mockAccountScreen.getUsername() + 
      " and password: " + mockAccountScreen.getPasswword() + " found in server. logging in", response);

    // credentials that aren't present previously
    String[] notValidLoginTxt = new String[]{"true", "not", "valid"};
    MockAccountScreen automaticLogin2 = new MockAccountScreen(notValidLoginTxt);
    response = mockLoginModel.performRequest(
      "PUT", automaticLogin2.getUsername(), automaticLogin2.getPasswword(), null);
    
    // 3 reacts appropriate to not recognized credentials
    assertEquals("put username: not and password: valid into server", response);
  }

  /*
   * STORY TEST - regenerate recipe
   *
   * 1 - reprompt ChatGPT
   * 2 - recipe with same meal type and ingredients expected
   * 
   * This tests regenerating a recipe with previous data
   * 
   */
  @Test
  void testRegenerateRecipe() {
    // create new recipe normally
    String transcribedMealType = "";
    String transcribedIngredients = "";

    mockWhisper.recordingMealType = true;
    try {
      transcribedMealType = mockWhisper.transcribe();
    } catch (Exception e) {}

    mockWhisper.recordingMealType = false;
    try {
      transcribedIngredients = mockWhisper.transcribe();
    } catch (Exception e) {}

    try {
      mockGPT.newRecipe(transcribedMealType, transcribedIngredients);
    } catch (Exception e) {}

    // 1 reprompt ChatGPT
    MockRegenerateBehavior regenerator = new MockRegenerateBehavior();
    RecipeDetailsMock separateMockGPT = new RecipeDetailsMock();
    try {
      separateMockGPT.newRecipe(mockGPT.getMealType(), regenerator.regenerate(mockWhisper));
    } catch (IOException | InterruptedException | URISyntaxException e) {}
    
    // 2 recipe with same parameters generated
    // comparing original recipe with regenerated recipe
    assertEquals(mockGPT.requestBody.toString(), separateMockGPT.requestBody.toString());
    assertEquals(mockGPT.getRecipe(), separateMockGPT.getRecipe());
    assertEquals(mockGPT.getRecipeName(), separateMockGPT.getRecipeName());
  }

  /*
   * STORY TEST - meal type tags
   *
   * 1 - recipe's meal type is perserved during generation
   * 2 - recipe is stored in database based on meal type
   * 
   * This tests repices perseving their meal type data as a tag
   * that also facilites sorting within the database
   * 
   */
  @Test
  void testMealTypeTags() {
    // generate new recipe normally
    String transcribedMealType = "";
    String transcribedIngredients = "";

    mockWhisper.recordingMealType = true;
    try {
      transcribedMealType = mockWhisper.transcribe();
    } catch (Exception e) {}

    mockWhisper.recordingMealType = false;
    try {
      transcribedIngredients = mockWhisper.transcribe();
    } catch (Exception e) {}

    try {
      mockGPT.newRecipe(transcribedMealType, transcribedIngredients);
    } catch (Exception e) {}

    // create 2 new recipe objects
    // 1 using meal type from generation
    MockRecipe recipe = new MockRecipe(transcribedMealType);
    recipe.setRecipe(mockGPT.getRecipe());
    MockRecipe recipe2 = new MockRecipe(transcribedMealType);
    recipe2.setRecipe(mockGPT.getRecipe() + "2");

    // 2 storing and retrieving recipes of meal type from database
    MockRequestHandler mockRequestHandler = new MockRequestHandler();
    mockRequestHandler.handlePost(recipe.toString());
    mockRequestHandler.handlePost(recipe2.toString());

    List<String> recipes = new ArrayList();
    recipes.add(recipe.getRecipe());
    recipes.add(recipe2.getRecipe());
    assertEquals(recipes, mockRequestHandler.retreiveAllRecipesOfMealTypeTag(recipe.getMealType()));
  }

  /*
   * STORY TEST - generate recipe with picture
   *
   * 1 - update recipe creation to include image generation
   * 2 - assign generated image to recipe
   * 
   * This tests recipe generation with images
   * 
   */
  @Test
  void testGenerateRecipeWithPicture() {
    // generate new recipe normally
    String transcribedMealType = "";
    String transcribedIngredients = "";

    mockWhisper.recordingMealType = true;
    try {
      transcribedMealType = mockWhisper.transcribe();
    } catch (Exception e) {}

    mockWhisper.recordingMealType = false;
    try {
      transcribedIngredients = mockWhisper.transcribe();
    } catch (Exception e) {}

    try {
      mockGPT.newRecipe(transcribedMealType, transcribedIngredients);
    } catch (Exception e) {}

    // 1 update recipe creation to include image generation
    mockGPT.generateImage();

    MockRecipe recipe = new MockRecipe(transcribedMealType);
    recipe.setRecipe(mockGPT.getRecipe());
    // 2 assign generated image to recipe
    recipe.setImageURL(mockGPT.getImageURL());

    assertEquals(mockGPT.getImageURL(), recipe.getImageURL());
  }

  /*
   * UNIT TEST
   *
   * isServerRunning() should:  1) check if server is running
   *                            2) return conclusion
   */
  @Test
  void testServerDown(){
    assertEquals(false, new MyServer().isServerRunning());
  }

  /*
   * STORY TEST - share recipe
   *
   * 1 - recipe data is used to generate a key that is part of a sharable link
   * 2 - using link, the database is accessed to retrieve the recipe
   * 
   * This tests sharing recipes by letting others access the same
   * recipe data stored in the database via a link
   * 
   */
  @Test
  void testShareRecipe() {
    // generate new recipe normally
    String transcribedMealType = "";
    String transcribedIngredients = "";

    mockWhisper.recordingMealType = true;
    try {
      transcribedMealType = mockWhisper.transcribe();
    } catch (Exception e) {}

    mockWhisper.recordingMealType = false;
    try {
      transcribedIngredients = mockWhisper.transcribe();
    } catch (Exception e) {}

    try {
      mockGPT.newRecipe(transcribedMealType, transcribedIngredients);
    } catch (Exception e) {}

    // putting recipe into database
    MockRecipe recipe = new MockRecipe(transcribedMealType);
    recipe.setRecipe(mockGPT.getRecipe());
    MockRequestHandler mockRequestHandler = new MockRequestHandler();
    mockRequestHandler.handlePost(recipe.toString());
    recipe.setIndex(mockRequestHandler.getIndex(transcribedMealType));

    // 1 convert recipe to sharable link
    String sharableLink = recipe.toLink();

    // 2 retrieve data with link
    String recipeData = mockRequestHandler.handle(sharableLink);

    assertEquals(recipe.getRecipe(), recipeData);
  }

  /*
   * STORY TEST - filter by meal type
   *
   * 1 - filter to show only breakfasts
   * 2 - filter to show only lunches
   * 3 - filter to show only dinners
   * 4 - clear filter to show all recipes
   * 
   * This tests the functionality of the filter to show only
   * recipes corresponding to the appropriate meal type tag(s)
   * 
   */
  @Test
  void testFilterByMealType() {
    // generate new recipe normally
    String transcribedMealType = "";
    String transcribedIngredients = "";

    mockWhisper.recordingMealType = true;
    try {
      transcribedMealType = mockWhisper.transcribe();
    } catch (Exception e) {}

    mockWhisper.recordingMealType = false;
    try {
      transcribedIngredients = mockWhisper.transcribe();
    } catch (Exception e) {}

    try {
      mockGPT.newRecipe(transcribedMealType, transcribedIngredients);
    } catch (Exception e) {}

    // create a breakfast and a lunch recipe
    MockRecipe recipe = new MockRecipe("breakfast");
    recipe.setRecipe(mockGPT.getRecipe());
    MockRecipe recipe2 = new MockRecipe("lunch");
    recipe2.setRecipe(mockGPT.getRecipe() + "2");

    // storing recipes
    MockRequestHandler mockRequestHandler = new MockRequestHandler();
    mockRequestHandler.handlePost(recipe.toString());
    mockRequestHandler.handlePost(recipe2.toString());

    // when filtered to breakfast, get recipe, the breakfast
    assertEquals(recipe.getRecipe(), mockRequestHandler.toString(
      mockRequestHandler.retreiveAllRecipesOfMealTypeTag("breakfast")));

    // when filtered to lunch, get recipe2, the lunch
    assertEquals(recipe2.getRecipe(), mockRequestHandler.toString(
      mockRequestHandler.retreiveAllRecipesOfMealTypeTag("lunch")));

    // when filtered to dinner, get nothing, since no dinner was put into the database
    assertEquals(null, mockRequestHandler.toString(
      mockRequestHandler.retreiveAllRecipesOfMealTypeTag("dinner")));

    // when no filter is set, get recipe and recipe2
    assertEquals(recipe2.getRecipe() + " " + recipe.getRecipe(), 
      mockRequestHandler.retreiveAllRecipesOfMealTypeTag());
  }

  /*
   * STORY TEST - sort alphabetically
   *
   * 1 - recipes are sorted
   * 
   * This tests the option to sort recipe names alphabetically
   * 
   */
  @Test
  void testSortAlphabetically() {
    // generate new recipe normally
    String transcribedMealType = "";
    String transcribedIngredients = "";

    mockWhisper.recordingMealType = true;
    try {
      transcribedMealType = mockWhisper.transcribe();
    } catch (Exception e) {}

    mockWhisper.recordingMealType = false;
    try {
      transcribedIngredients = mockWhisper.transcribe();
    } catch (Exception e) {}

    try {
      mockGPT.newRecipe(transcribedMealType, transcribedIngredients);
    } catch (Exception e) {}

    // creating and storing in database 2 recipes
    MockRecipe recipe = new MockRecipe(transcribedMealType);
    recipe.setRecipe("b" + mockGPT.getRecipe());
    MockRecipe recipe2 = new MockRecipe(transcribedMealType);
    recipe2.setRecipe("a" + mockGPT.getRecipe());

    MockRequestHandler mockRequestHandler = new MockRequestHandler();
    mockRequestHandler.handlePost(recipe.toString());
    mockRequestHandler.handlePost(recipe2.toString());

    List<String> recipes = new ArrayList();
    recipes.add(recipe.getRecipe());
    recipes.add(recipe2.getRecipe());
    // 1 recipes are sorted
    mockRequestHandler.sort("A->Z");
    // coompare with expect sorted list of recipes
    Collections.sort(recipes);
    assertEquals(recipes, mockRequestHandler.retreiveAllRecipesOfMealTypeTag(recipe.getMealType()));
  }
}
